<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node circle {
  fill: #999;
}

.node text {
  font-family: sans-serif;
}

.node-internal circle {
  fill: #fff;
  stroke: #555;
  stroke-width: 1;
}

.node-internal text {
  text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
}

.link {
  fill: none;
  stroke: #555;
  stroke-opacity: 0.4;
  stroke-width: 1.5px;
}

.snippet {
    font-family: monospace;
    white-space: pre;
}

svg path.function {
    fill: #000000;
    fill-opacity: 0.05;
    stroke: #000000;
    stroke-width: 0.9px;
    stroke-dasharray: 5 5;
}

svg path.function.level-1 {
    fill-opacity: 0.03;
}

svg path.function:hover {
    fill-opacity: 0.1;
}

svg text {
    cursor: default;
}
</style>

<svg width="1200" height="1200">
</svg>

<script src="//d3js.org/d3.v4.js"></script>
<script>

var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = 400, //+svg.attr("height"),
    g = svg.append("g").attr("transform", "translate(60,0)");

// ATTENTION width and height are swapped because we have a horizontal tree layout!
// var tree = d3.cluster().size([height, 1]);
var NODE_HEIGHT = 50,
    MAX_DEPTH = 12;

var tree = d3.tree().nodeSize([NODE_HEIGHT,1/MAX_DEPTH]);

function x(x0) {
    return (1-x0) * (width - 180)
}
/*
var stratify = d3.stratify()
    .parentId(function(d) { return d.id.substring(0, d.id.lastIndexOf(".")); });
*/
d3.json("examples/mercator.json", function(error, treeData) {
  if (error) throw error;

  var yOffset = 300;
  
  g.selectAll(".tree")
    .data(treeData)
    .enter()
    .append("g")
    .attr("class", "tree")
    .each(function(d,i) {
    
        var g = d3.select(this);
        
        g.attr("transform","translate(0," + yOffset + ")");
        
        var root = d3.hierarchy(d, node => node.inputs);
        tree(root);

        yOffset += 400;
        

        function hasHead(head, array, comparator) {
            return head.reduce(function(acc, el, i) {
                return acc && array.length > i && comparator(el, array[i]); 
            }, true);
        }
        
        function hasStackHead(head, stack) {
            return hasHead(head, stack, function(el1, el2) {
                return (el1.file == el2.file) && (el1.loc == el2.loc);
            });
        }
        
        function getEdgeNodes(node, stack, edgeNodes) {
            if (node.children) {
                let lastInNode = null,
                    lastOutNode = null;
                node.children.forEach(function(n) {
                    if (hasStackHead(stack, n.data.stack)) {
                        if (lastOutNode) {
                            edgeNodes.push({node: lastOutNode, inside: false});
                        }
                        if (!lastInNode) {
                            edgeNodes.push({node: n, inside: true});
                        }
                        getEdgeNodes(n, stack, edgeNodes);
                        lastInNode = n;
                        lastOutNode = null;
                    }
                    else {
                        if (lastInNode) {
                            lastOutNode = n;
                        }
                    }    
                });
                edgeNodes.push({node: lastInNode, inside: true});
            }            
        }
        
        //console.log(edgeNodes.map(n => n.node.data.loc + ":" + n.node.data.stack[0].name + ":" + n.inside));
        
        function drawOutline(edgeNodes, level) {
        
            var path = [];
            var previous, current, next;
            var root = edgeNodes[0];
            
            level = level || 1;
            var margin = (level-1) * 4 + 2;
            
            var radius = NODE_HEIGHT / 2 - margin;
            
            for (var i=0; i<edgeNodes.length; i++) {
                previous = edgeNodes[i-1] || null;
                current = edgeNodes[i];
                next = edgeNodes[i+1] || null;
                
                // draw smooth connection from PREVIOUS to CURRENT node in every iteration, providing correct tangent for NEXT
                // usually, down the tree is on top, back up is at bottom
                if (!previous) {
                    // root node
                    path.push("M" + [x(current.node.y),current.node.x+radius])
                    path.push("A" + [                   // circular arc
                        radius, radius,   // radius-x, radius-y
                        0, 0, 0,                        // x-axis-rotation large-arc-flag sweep-flag
                        x(current.node.y), current.node.x-radius // dest x, y
                    ]);
                    // special case: only 1 node
                    if (next == current) {
                        path.push("A" + [                   // circular arc
                            radius, radius,   // radius-x, radius-y
                            0, 0, 0,                        // x-axis-rotation large-arc-flag sweep-flag
                            x(current.node.y), current.node.x+radius // dest x, y
                        ]);
                    }
                }
                else {
                    if (current.inside) {
                        if (previous.node.depth < current.node.depth) {
                            path.push("C" + [                                                       // bezier curve 
                                x(previous.node.y)-2*radius, previous.node.x-radius,      // cp1 x, y
                                x(current.node.y)+2*radius, current.node.x-radius,        // cp2 x, y
                                x(current.node.y), current.node.x-radius                     // dest x, y
                            ]);
                            if (next == null || current.node.depth == next.node.depth) {
                                if (next.inside) {
                                    path.push("A" + [                   // circular arc
                                        radius, radius,   // radius-x, radius-y
                                        0, 0, 0,                        // x-axis-rotation large-arc-flag sweep-flag
                                        x(current.node.y)-radius, current.node.x // dest x, y
                                    ]);
                                }
                                else {
                                    path.push("A" + [                   // circular arc
                                        radius, radius,   // radius-x, radius-y
                                        0, 0, 0,                        // x-axis-rotation large-arc-flag sweep-flag
                                        x(current.node.y), current.node.x+radius // dest x, y
                                    ]);
                                }
                            }
                        }
                        else if (previous.node.depth == current.node.depth) {
                            if (next.node.depth > current.node.depth) {
                                path.push("L" + [x(current.node.y), current.node.x-NODE_HEIGHT*3/4]);
                                path.push("C" + [                                                       // bezier curve 
                                    x(current.node.y), current.node.x-radius,        // cp1 x, y
                                    x(current.node.y), current.node.x-radius,        // cp2 x, y
                                    x(current.node.y)-radius/2, current.node.x-radius                     // dest x, y
                                ]);
                            }
                            else {
                                path.push("L" + [x(current.node.y)-radius, current.node.x]);
                            }
                            if (current.node.depth > next.node.depth || !next.inside) {
                                path.push("A" + [                   // circular arc
                                    radius, radius,   // radius-x, radius-y
                                    0, 0, 0,                        // x-axis-rotation large-arc-flag sweep-flag
                                    x(current.node.y), current.node.x+radius // dest x, y
                                ]);
                            }
                        }
                        else if (previous.node.depth > current.node.depth) {
                            if (next && current.node.depth == next.node.depth) {
                                path.push("C" + [                                                       // bezier curve 
                                    x(previous.node.y)+2*radius, previous.node.x+radius,      // cp1 x, y
                                    x(current.node.y)-2*radius, current.node.x+radius,        // cp2 x, y
                                    x(current.node.y)-radius/2, current.node.x+radius                     // dest x, y
                                ]);
                                path.push("C" + [                                                       // bezier curve 
                                    x(current.node.y), current.node.x+radius,                    // cp1 x, y
                                    x(current.node.y), current.node.x+radius,        // cp2 x, y
                                    x(current.node.y), current.node.x+radius*1.5                     // dest x, y
                                ]);
                            }
                            else {
                                path.push("C" + [                                                       // bezier curve 
                                    x(previous.node.y)+2*radius, previous.node.x+radius,      // cp1 x, y
                                    x(current.node.y)-2*radius-margin, current.node.x+radius,        // cp2 x, y
                                    x(current.node.y), current.node.x+radius                     // dest x, y
                                ]);
                            }
                        }
                    }
                }
            }
            
            var d = path.join(" ");
            var path = g.append("path")
                .attr("class","function level-"+level)
                .attr("d", d)
            ;
        }
        
        
        function walkTree(node, lastStack) {
        
            lastStack = lastStack || [];
            currentStack = node.data.stack || [];
            
            if (!hasStackHead(currentStack, lastStack)) {
                var edgeNodes = [{node: node, inside: true}];
                getEdgeNodes(node, currentStack, edgeNodes);
                edgeNodes.push({node: node, inside: true});
                
                drawOutline(edgeNodes, currentStack.length);
            }

            if (node.children) {
                node.children.forEach(n => walkTree(n, node.data.stack));
            }
        }
        
        walkTree(root);
       
        var link = g.selectAll(".link")
          .data(root.descendants().slice(1))
        .enter().append("path")
          .attr("class", "link")
          .attr("d", function(d) {
            return "M" + x(d.y) + "," + d.x
                + "C" + (x(d.parent.y) - 50) + "," + d.x
                + " " + (x(d.parent.y) - 50) + "," + d.parent.x
                + " " + x(d.parent.y) + "," + d.parent.x;
          });
          
        function round(val, digits) {
            if (typeof val == "number") {
                let base = Math.pow(10, digits);
                val = Math.round(val*base)/base;
            }
            return val;
        }

        var node = g.selectAll(".node")
          .data(root.descendants())
        .enter().append("g")
          .attr("class", function(d) { return "node" + (d.children ? " node-internal" : " node-leaf"); })
          .attr("transform", function(d) { 
            return "translate(" + x(d.y) + "," + d.x + ")"; 
          })

        node.append("circle")
          .attr("r", d => d.data.op ? 8 : 5);

        node.append("text")
          .attr("dy", 4)
          .attr("x", d => d.height ? 15 : -9)
          .attr("font-size", 12)
          .attr("text-anchor", d => d.height ? "start" : "end")
          .text(d => d.data.valuetype == "string" ? '"'+d.data.val+'"' : round(d.data.val,4));
          
        node.append("text")
          .attr("dy", 4)
          .attr("x", 0)
          .attr("text-anchor", "middle")
          .attr("font-size", 12)
          .text(d => d.data.op || "");

/*          
        node.append("text")
          .attr("dy", 16)
          .attr("x", 0)
          .attr("text-anchor", "middle")
          .attr("font-size", 10)
          .text(d => {
                if (d.data.stack && d.data.stack.length > 0) {
                    return d.data.stack[d.data.stack.length-1].name || "";
                }
                return "";
          })
        ;
*/        
    });
});

</script>
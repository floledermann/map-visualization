<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node circle {
  fill: #999;
}

.node text {
  font-family: sans-serif;
}

.node-internal circle {
  fill: #fff;
  stroke: #555;
  stroke-width: 1;
}

.node-internal text {
  text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
}

.link {
  fill: none;
  stroke: #555;
  stroke-opacity: 0.4;
  stroke-width: 1.5px;
}

.snippet {
    font-family: monospace;
    white-space: pre;
}

svg path.function {
    fill: #000000;
    fill-opacity: 0.05;
    stroke: #000000;
    stroke-width: 2px;
    stroke-dasharray: 5 5;
}
</style>

<svg width="1200" height="1200">
<path class="function" d="M 200 100 c 10 0, 20 10, 20 20 s -10 20, -20 20 c -50 0, -50 20, -100 20"/>
</svg>

<script src="//d3js.org/d3.v4.js"></script>
<script>

var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = 400, //+svg.attr("height"),
    g = svg.append("g").attr("transform", "translate(60,0)");

// ATTENTION width and height are swapped because we have a horizontal tree layout!
// var tree = d3.cluster().size([height, 1]);
var NODE_HEIGHT = 50;

var tree = d3.tree().nodeSize([NODE_HEIGHT,0.1]); //.size([height, 1]);

function x(x0) {
    return (1-x0) * (width - 180)
}
/*
var stratify = d3.stratify()
    .parentId(function(d) { return d.id.substring(0, d.id.lastIndexOf(".")); });
*/
d3.json("examples/simple.json", function(error, treeData) {
  if (error) throw error;

  var yOffset = 300;
  
  g.selectAll(".tree")
    .data(treeData)
    .enter()
    .append("g")
    .attr("class", "tree")
    .each(function(d,i) {
    
        var g = d3.select(this);
        
        g.attr("transform","translate(0," + yOffset + ")");
        
        var root = d3.hierarchy(d, node => node.inputs);
        tree(root);

        yOffset += 400;
        
        var link = g.selectAll(".link")
          .data(root.descendants().slice(1))
        .enter().append("path")
          .attr("class", "link")
          .attr("d", function(d) {
            return "M" + x(d.y) + "," + d.x
                + "C" + (x(d.parent.y) - 50) + "," + d.x
                + " " + (x(d.parent.y) - 50) + "," + d.parent.x
                + " " + x(d.parent.y) + "," + d.parent.x;
          });
          
        function round(val, digits) {
            if (typeof val == "number") {
                let base = Math.pow(10, digits);
                val = Math.round(val*base)/base;
            }
            return val;
        }

        var node = g.selectAll(".node")
          .data(root.descendants())
        .enter().append("g")
          .attr("class", function(d) { return "node" + (d.children ? " node-internal" : " node-leaf"); })
          .attr("transform", function(d) { 
            return "translate(" + x(d.y) + "," + d.x + ")"; 
          })

        node.append("circle")
          .attr("r", d => d.data.op ? 8 : 5);

        node.append("text")
          .attr("dy", 4)
          .attr("x", d => d.height ? 15 : -9)
          .attr("font-size", 12)
          .attr("text-anchor", d => d.height ? "start" : "end")
          .text(d => d.data.valuetype == "string" ? '"'+d.data.val+'"' : round(d.data.val,4));
          
        node.append("text")
          .attr("dy", 4)
          .attr("x", 0)
          .attr("text-anchor", "middle")
          .attr("font-size", 12)
          .text(d => d.data.op || "");

          
        node.append("text")
          .attr("dy", 16)
          .attr("x", 0)
          .attr("text-anchor", "middle")
          .attr("font-size", 10)
          .text(d => {
                if (d.data.stack && d.data.stack.length > 0) {
                    return d.data.stack[d.data.stack.length-1].name || "";
                }
                return "";
          })
        ;
        
        function walkTree(node, stack) {
            stack = stack || [];
            if (node.data.stack && node.data.stack.length > stack.length) {
                // start function context
                var path = g.append("path")
                    .attr("class","function")
                    .attr("d", "M " + x(node.y) + " " + (node.x-NODE_HEIGHT/2) + " c " + (NODE_HEIGHT/4) + " 0, " + (NODE_HEIGHT/2) + " " + (NODE_HEIGHT/4) + ", " + (NODE_HEIGHT/2) + " " + (NODE_HEIGHT/2) + " s " + (-NODE_HEIGHT/4) + " " + (NODE_HEIGHT/2) + ", " + (-NODE_HEIGHT/2) + " " + (NODE_HEIGHT/2) + " ");
            }
            if ((node.data.stack && node.data.stack.length < stack.length)) {
                // previous function context ended before current node
                var path = g.append("path")
                    .attr("class","function")
                    .attr("d", "M " + (x(node.y)+NODE_HEIGHT) + " " + (node.x-NODE_HEIGHT/2) + " c " + (-NODE_HEIGHT/4) + " 0, " + (-NODE_HEIGHT/2) + " " + (NODE_HEIGHT/4) + ", " + (-NODE_HEIGHT/2) + " " + (NODE_HEIGHT/2) + " s " + (NODE_HEIGHT/4) + " " + (NODE_HEIGHT/2) + ", " + (NODE_HEIGHT/2) + " " + (NODE_HEIGHT/2) + " ");
            }
            if (!node.children && node.data.stack && node.data.stack.length > 0) {
                // end function context - leaf node
                var path = g.append("path")
                    .attr("class","function")
                    .attr("d", "M " + x(node.y) + " " + (node.x-NODE_HEIGHT/2) + " c " + (-NODE_HEIGHT/4) + " 0, " + (-NODE_HEIGHT/2) + " " + (NODE_HEIGHT/4) + ", " + (-NODE_HEIGHT/2) + " " + (NODE_HEIGHT/2) + " s " + (NODE_HEIGHT/4) + " " + (NODE_HEIGHT/2) + ", " + (NODE_HEIGHT/2) + " " + (NODE_HEIGHT/2) + " ");
            }
            if (node.children) {
                node.children.forEach(n => walkTree(n, node.data.stack));
            }
        }
        
        walkTree(root);

    });
});

</script>
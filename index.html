<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node circle {
  fill: #999;
}

.node text {
  font-family: sans-serif;
}

.node-internal circle {
  fill: #fff;
  stroke: #555;
  stroke-width: 1;
}

.node-internal text {
  text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
}

.link {
  fill: none;
  stroke: #555;
  stroke-opacity: 0.4;
  stroke-width: 1.5px;
}

.snippet {
    font-family: monospace;
    white-space: pre;
}

svg path.function {
    fill: #000000;
    fill-opacity: 0.03;
    stroke: #000000;
    stroke-width: 1.3px;
    stroke-dasharray: 5 5;
}
</style>

<svg width="1200" height="1200">
<path class="function" d="M 200 100 c 10 0, 20 10, 20 20 s -10 20, -20 20 c -50 0, -50 20, -100 20"/>
</svg>

<script src="//d3js.org/d3.v4.js"></script>
<script>

var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = 400, //+svg.attr("height"),
    g = svg.append("g").attr("transform", "translate(60,0)");

// ATTENTION width and height are swapped because we have a horizontal tree layout!
// var tree = d3.cluster().size([height, 1]);
var NODE_HEIGHT = 50;

var tree = d3.tree().nodeSize([NODE_HEIGHT,0.1]); //.size([height, 1]);

function x(x0) {
    return (1-x0) * (width - 180)
}
/*
var stratify = d3.stratify()
    .parentId(function(d) { return d.id.substring(0, d.id.lastIndexOf(".")); });
*/
d3.json("examples/tests_treeviz.json", function(error, treeData) {
  if (error) throw error;

  var yOffset = 300;
  
  g.selectAll(".tree")
    .data(treeData)
    .enter()
    .append("g")
    .attr("class", "tree")
    .each(function(d,i) {
    
        var g = d3.select(this);
        
        g.attr("transform","translate(0," + yOffset + ")");
        
        var root = d3.hierarchy(d, node => node.inputs);
        tree(root);

        yOffset += 400;
        
        var link = g.selectAll(".link")
          .data(root.descendants().slice(1))
        .enter().append("path")
          .attr("class", "link")
          .attr("d", function(d) {
            return "M" + x(d.y) + "," + d.x
                + "C" + (x(d.parent.y) - 50) + "," + d.x
                + " " + (x(d.parent.y) - 50) + "," + d.parent.x
                + " " + x(d.parent.y) + "," + d.parent.x;
          });
          
        function round(val, digits) {
            if (typeof val == "number") {
                let base = Math.pow(10, digits);
                val = Math.round(val*base)/base;
            }
            return val;
        }

        var node = g.selectAll(".node")
          .data(root.descendants())
        .enter().append("g")
          .attr("class", function(d) { return "node" + (d.children ? " node-internal" : " node-leaf"); })
          .attr("transform", function(d) { 
            return "translate(" + x(d.y) + "," + d.x + ")"; 
          })

        node.append("circle")
          .attr("r", d => d.data.op ? 8 : 5);

        node.append("text")
          .attr("dy", 4)
          .attr("x", d => d.height ? 15 : -9)
          .attr("font-size", 12)
          .attr("text-anchor", d => d.height ? "start" : "end")
          .text(d => d.data.valuetype == "string" ? '"'+d.data.val+'"' : round(d.data.val,4));
          
        node.append("text")
          .attr("dy", 4)
          .attr("x", 0)
          .attr("text-anchor", "middle")
          .attr("font-size", 12)
          .text(d => d.data.op || "");

          
        node.append("text")
          .attr("dy", 16)
          .attr("x", 0)
          .attr("text-anchor", "middle")
          .attr("font-size", 10)
          .text(d => {
                if (d.data.stack && d.data.stack.length > 0) {
                    return d.data.stack[d.data.stack.length-1].name || "";
                }
                return "";
          })
        ;
        
        function hasHead(head, array, comparator) {
            return head.reduce(function(acc, el, i) {
                return acc && array.length > i && comparator(el, array[i]); 
            }, true);
        }
        
        function hasStackHead(head, stack) {
            return hasHead(head, stack, function(el1, el2) {
                return (el1.file == el2.file) && (el1.loc == el2.loc);
            });
        }
        
        function getEdgeNodes(node, stack, edgeNodes) {
            if (node.children) {
                let lastInNode = null,
                    lastOutNode = null;
                node.children.forEach(function(n) {
                    if (hasStackHead(stack, n.data.stack)) {
                        if (lastOutNode) {
                            edgeNodes.push({node: lastOutNode, inside: false});
                        }
                        if (!lastInNode) {
                            edgeNodes.push({node: n, inside: true});
                        }
                        getEdgeNodes(n, stack, edgeNodes);
                        lastInNode = n;
                        lastOutNode = null;
                    }
                    else {
                        if (lastInNode) {
                            lastOutNode = n;
                        }
                    }    
                });
                edgeNodes.push({node: lastInNode, inside: true});
            }            
        }
        
        var edgeNodes = [{node: root, inside: true}];
        getEdgeNodes(root, root.data.stack, edgeNodes);
        edgeNodes.push({node: root, inside: true});
        
        //console.log(edgeNodes.map(n => n.node.data.loc + ":" + n.node.data.stack[0].name + ":" + n.inside));
        
        function drawOutline(edgeNodes) {
            var path = [];
            var previous, current, next;
            var root = edgeNodes[0];
            
            for (var i=0; i<edgeNodes.length; i++) {
                previous = edgeNodes[i-1] || null;
                current = edgeNodes[i];
                next = edgeNodes[i+1] || root;
                
                // draw smooth connection from PREVIOUS to CURRENT node in every iteration, providing correct tangent for NEXT
                if (!previous) {
                    // root node
                    path.push("M" + [x(current.node.y),current.node.x+NODE_HEIGHT/2])
                    path.push("A" + [                   // circular arc
                        NODE_HEIGHT/2, NODE_HEIGHT/2,   // radius-x, radius-y
                        0, 0, 0,                        // x-axis-rotation large-arc-flag sweep-flag
                        x(current.node.y), current.node.x-NODE_HEIGHT/2 // dest x, y
                    ]);
                }
                else {
                    if (current.inside) {
                        if (previous.node.depth < current.node.depth) {
                            path.push("C" + [                                                       // bezier curve 
                                x(previous.node.y)-NODE_HEIGHT, previous.node.x-NODE_HEIGHT/2,      // cp1 x, y
                                x(current.node.y)+NODE_HEIGHT, current.node.x-NODE_HEIGHT/2,        // cp2 x, y
                                x(current.node.y), current.node.x-NODE_HEIGHT/2                     // dest x, y
                            ]);
                            if (current.node.depth == next.node.depth) {
                                if (next.inside) {
                                    path.push("A" + [                   // circular arc
                                        NODE_HEIGHT/2, NODE_HEIGHT/2,   // radius-x, radius-y
                                        0, 0, 0,                        // x-axis-rotation large-arc-flag sweep-flag
                                        x(current.node.y)-NODE_HEIGHT/2, current.node.x // dest x, y
                                    ]);
                                }
                                else {
                                    path.push("A" + [                   // circular arc
                                        NODE_HEIGHT/2, NODE_HEIGHT/2,   // radius-x, radius-y
                                        0, 0, 0,                        // x-axis-rotation large-arc-flag sweep-flag
                                        x(current.node.y), current.node.x+NODE_HEIGHT/2 // dest x, y
                                    ]);
                                }
                            }
                        }
                        else if (previous.node.depth == current.node.depth) {
                            if (next.node.depth > current.node.depth) {
                                path.push("L" + [x(current.node.y), current.node.x-NODE_HEIGHT/2]);
                            }
                            else {
                                path.push("L" + [x(current.node.y)-NODE_HEIGHT/2, current.node.x]);
                            }
                            if (current.node.depth > next.node.depth || !next.inside) {
                                path.push("A" + [                   // circular arc
                                    NODE_HEIGHT/2, NODE_HEIGHT/2,   // radius-x, radius-y
                                    0, 0, 0,                        // x-axis-rotation large-arc-flag sweep-flag
                                    x(current.node.y), current.node.x+NODE_HEIGHT/2 // dest x, y
                                ]);
                            }
                        }
                        else if (previous.node.depth > current.node.depth) {
                            path.push("C" + [                                                       // bezier curve 
                                x(previous.node.y)+NODE_HEIGHT, previous.node.x+NODE_HEIGHT/2,      // cp1 x, y
                                x(current.node.y)-NODE_HEIGHT, current.node.x+NODE_HEIGHT/2,        // cp2 x, y
                                x(current.node.y), current.node.x+NODE_HEIGHT/2                     // dest x, y
                            ]);
                        }
                    }
                }
            }
            
            var d = path.join(" ");
            var path = g.append("path")
                .attr("class","function")
                .attr("d", d)
            ;
        }
        
        drawOutline(edgeNodes);
        
        function walkTree(node, lastStack) {
        
            lastStack = lastStack || [];
            currentStack = node.data.stack || [];
            
            if (!hasStackHead(currentStack, lastStack)) {
                // start function context
                var path = g.append("path")
                    .attr("class","function")
                    .attr("d", "M " + x(node.y) + " " + (node.x-NODE_HEIGHT/2) + " c " + (NODE_HEIGHT/4) + " 0, " + (NODE_HEIGHT/2) + " " + (NODE_HEIGHT/4) + ", " + (NODE_HEIGHT/2) + " " + (NODE_HEIGHT/2) + " s " + (-NODE_HEIGHT/4) + " " + (NODE_HEIGHT/2) + ", " + (-NODE_HEIGHT/2) + " " + (NODE_HEIGHT/2) + " ");
            }
            if (currentStack.length < lastStack.length) {
                // previous function context ended before current node
                var path = g.append("path")
                    .attr("class","function")
                    .attr("d", "M " + (x(node.y)+NODE_HEIGHT) + " " + (node.x-NODE_HEIGHT/2) + " c " + (-NODE_HEIGHT/4) + " 0, " + (-NODE_HEIGHT/2) + " " + (NODE_HEIGHT/4) + ", " + (-NODE_HEIGHT/2) + " " + (NODE_HEIGHT/2) + " s " + (NODE_HEIGHT/4) + " " + (NODE_HEIGHT/2) + ", " + (NODE_HEIGHT/2) + " " + (NODE_HEIGHT/2) + " ");
            }
            if (!node.children && currentStack.length > 0) {
                // end function context - leaf node
                var path = g.append("path")
                    .attr("class","function")
                    .attr("d", "M " + x(node.y) + " " + (node.x-NODE_HEIGHT/2) + " c " + (-NODE_HEIGHT/4) + " 0, " + (-NODE_HEIGHT/2) + " " + (NODE_HEIGHT/4) + ", " + (-NODE_HEIGHT/2) + " " + (NODE_HEIGHT/2) + " s " + (NODE_HEIGHT/4) + " " + (NODE_HEIGHT/2) + ", " + (NODE_HEIGHT/2) + " " + (NODE_HEIGHT/2) + " ");
            }
            if (node.children) {
                node.children.forEach(n => walkTree(n, node.data.stack));
            }
        }
        
        //walkTree(root);

    });
});

</script>
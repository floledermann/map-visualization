<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node circle {
  fill: #999;
}

.node text {
  font-family: sans-serif;
}

.node-internal circle {
  fill: #fff;
  stroke: #555;
  stroke-width: 1;
}

.node-internal text {
  text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
}

.link {
  fill: none;
  stroke: #555;
  stroke-opacity: 0.4;
  stroke-width: 1.5px;
}

.snippet {
    font-family: monospace;
    white-space: pre;
}
</style>

<svg width="1200" height="1200"></svg>
<script src="//d3js.org/d3.v4.js"></script>
<script>

var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = 400, //+svg.attr("height"),
    g = svg.append("g").attr("transform", "translate(60,0)");

// ATTENTION width and height are swapped because we have a horizontal tree layout!
//var tree = d3.cluster().size([height, 1]);
var tree = d3.tree().nodeSize([30,0.1]); //.size([height, 1]);

function x(x0) {
    return (1-x0) * (width - 180)
}
/*
var stratify = d3.stratify()
    .parentId(function(d) { return d.id.substring(0, d.id.lastIndexOf(".")); });
*/
d3.json("examples/simple.json", function(error, treeData) {
  if (error) throw error;

  var yOffset = 200;
  
  g.selectAll(".tree")
    .data(treeData)
    .enter()
    .append("g")
    .attr("class", "tree")
    .each(function(d,i) {
    
        var g = d3.select(this);
        
        g.attr("transform","translate(0," + yOffset + ")");
        
        var root = d3.hierarchy(d, node => node.inputs);
        tree(root);

        yOffset += 200;
        
        var link = g.selectAll(".link")
          .data(root.descendants().slice(1))
        .enter().append("path")
          .attr("class", "link")
          .attr("d", function(d) {
            return "M" + x(d.y) + "," + d.x
                + "C" + (x(d.parent.y) - 50) + "," + d.x
                + " " + (x(d.parent.y) - 50) + "," + d.parent.x
                + " " + x(d.parent.y) + "," + d.parent.x;
          });
          
        function round(val, digits) {
            if (typeof val == "number") {
                let base = Math.pow(10, digits);
                val = Math.round(val*base)/base;
            }
            return val;
        }

        var node = g.selectAll(".node")
          .data(root.descendants())
        .enter().append("g")
          .attr("class", function(d) { return "node" + (d.children ? " node-internal" : " node-leaf"); })
          .attr("transform", function(d) { 
            return "translate(" + x(d.y) + "," + d.x + ")"; 
          })

        node.append("circle")
          .attr("r", d => d.data.op ? 8 : 5);

        node.append("text")
          .attr("dy", 4)
          .attr("x", d => d.height ? 15 : -9)
          .attr("font-size", 12)
          .attr("text-anchor", d => d.height ? "start" : "end")
          .text(d => d.data.valuetype == "string" ? '"'+d.data.val+'"' : round(d.data.val,4));
          
        node.append("text")
          .attr("dy", 4)
          .attr("x", 0)
          .attr("text-anchor", "middle")
          .attr("font-size", 12)
          .text(d => d.data.op || "");
          
        node.append("text")
          .attr("dy", 16)
          .attr("x", 0)
          .attr("text-anchor", "middle")
          .attr("font-size", 10)
          .text(d => {
                if (d.data.stack && d.data.stack.length > 0) {
                    return d.data.stack[d.data.stack.length-1].name || "";
                }
                return "";
          });
    });
});

</script>